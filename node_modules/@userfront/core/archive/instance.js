// Create an instanced Userfront Core JS library
import { apiUrl } from "./constants";
import { getQueryAttr } from "./url";
import Cookies from "js-cookie";
import { throwFormattedError, formatError } from "./utils";
import { isTestHostname, isHttps } from "./mode";

/**
 * Set the reason for the mode
 * - http
 * - domain
 */
function getReason(mode) {
  try {
    if (mode === "live") {
      return "domain";
    }
    if (window.location.protocol === "http:") {
      return "http";
    } else if (window.location.protocol !== "https:") {
      return "protocol";
    } else {
      return "domain";
    }
  } catch (error) {}
}

// Token store base + implementation

class TokenStore {
  constructor({
    tokens,
    tenantId
  }) {
    this.accessTokenName = "todo"
    this.idTokenName = "todo"
    this.refreshTokenName = "todo"
  }

  setCookie(value, options, type) {
    // can be overridden
    // options irrelevant outside cookies
    const key = `${type}.${tenantId}`;
    return this.set(key, value, options);
  }

  removeCookie(name) {
    // can be overridden
    return this.delete(name);
  }


  removeAllCookies() { return this.removeAll() }
  removeAll() {
    this.removeCookie(this.accessTokenName);
    this.removeCookie(this.idTokenName);
    this.removeCookie(this.refreshTokenName);
  }
}

class CookieTokenStore {

  setCookie(value, options, type) {
    const cookieName = `${type}.${store.tenantId}`;
    options = options || {
      secure: store.mode === "live",
      sameSite: "Lax"
    };
    if(type === "refresh") {
      options.sameSite = "Strict";
    }
    return this.set(cookieName, value, options)
  }

  removeCookie(name) {
    if (typeof window === "undefined" || !window) {
      console.log("Tried to remove cookies outside of the browser, skipping paths and domains.");
      return this.delete(name);
    }
    const path = window.location.pathname;
    const hostname = window.location.hostname;
    
    return this.removeCookieForAllPaths(name, path, hostname);
  }

  removeCookieForAllPaths(name, path, hostname) {
    // Define all possible path and domain combinations
    let paths, domains;
    try {
      const hostnameParts = hostname.split(".");
      const primaryDomain = hostnameParts.slice(-2).join(".");
      paths = [undefined, path, "/"];
      domains = [
        undefined,
        hostname,
        `.${hostname}`,
        primaryDomain,
        `.${primaryDomain}`,
      ];
    } catch (err) {
      paths = [undefined, "/"];
      domains = [undefined];
    }
  }

  set(key, value, options = {}) {
    return Cookies.set(key, value, options);
  }

  get(key) {
    return Cookies.get(key);
  }

  delete(key, options = {}) {
    return Cookies.remove(key, options);
  }

  clear() {

  }

}

class LocalStorageTokenStore {

}

class MemoryTokenStore {

}

// User API

// MFA service

class AuthService {
  constructor({ tokenStore }) {
    this.firstFactors = [];
    this.secondFactors = [];
    this.firstFactorToken = null;
    this.tokenStore = tokenStore;
  }

  get accessToken() {
    return this.tokenStore.accessToken;
  }

  get idToken() {
    return this.tokenStore.idToken;
  }

  get refreshToken() {
    return this.tokenStore.refreshToken;
  }

  setCookiesAndTokens(tokens) { return this.setTokens(tokens); }
  setTokens(tokens) {
    this.tokenStore.accessToken = tokens.access;
    this.tokenStore.idToken = tokens.id;
    if (tokens.refresh && tokens.refresh.value) {
      this.tokenStore.refreshToken = tokens.refresh;
    }
  }

  handleLoginResponse({
    data,
    redirect,
    handleUpstreamResponse,
    handleMfaRequired,
    handlePkceRequired,
    handleTokens,
    handleRedirect
  }) {
    const redirectValue = redirect
      || getQueryAttr("redirect")
      || data.redirectTo
      || "/"

    const promises = [];

    const returnAsync = it => Promise.all(promises).then(() => it);
    const callAsync = fn => (...args) => {
      if (typeof fn === "function") {
        promises.push(fn(...args));
        return true;
      }
      return false;
    }

    // TODO this is meh
    callAsync(handleUpstreamResponse)(data.upstreamResponse, data);

    if (data.hasOwnProperty("firstFactorToken")) {
      callAsync(handleMfaRequired)(data.firstFactorToken, data)
        || this.handleMfaRequired(data.firstFactorToken, data);
      return returnAsync(data);
    }

    if (data.hasOwnProperty("tokens")) {
      callAsync(handleTokens)(data.tokens, data)
        || callAsync(this.handleTokens(data.tokens, data));
    }

    if (data.hasOwnProperty("authorizationCode")) {
      if (!redirectValue) {
        throw new Error("Missing PKCE redirect URL");
      }
      callAsync(handlePkceRequired)(data.authorizationCode, redirectValue, data)
        || this.handlePkceRequired(data.authorizationCode, data);
      returnAsync(data);
    }

    if (data.hasOwnProperty("redirectTo") && redirect !== false) {
      callAsync(handleRedirect)(redirectValue, data)
        || this.handleRedirect(redirectValue, data);
    }

    returnAsync(data);
  }

  getMfaHeaders() {
    if (this.firstFactorToken) {
      return {
        authorization: `Bearer ${this.firstFactorToken}`
      }
    }
    return {}
  }

  clearMfa() {
    this.secondFactors = [];
    this.firstFactorToken = null;
  }

  resetMfa() {
    this.clearMfa();
    this.firstFactors = [];
  }

  setFirstFactors(authentication) {
    if (!authentication ||
      typeof authentication !== "object" ||
      !Array.isArray(authentication.firstFactors)
    ) {
      console.warn("setFirstFactors: invalid factors passed.");
      return;
    }
    this.firstFactors = authentication.firstFactors;
  }

  isFirstFactorTokenPresent() {
    return !!this.firstFactorToken;
  }

  handleMfaRequire(firstFactorToken, data) {
    if (!data.isMfaRequired) {
      if (data.message === "OK") {
        this.clearMfa();
      }
      return;
    }
    this.firstFactorToken = firstFactorToken;
    this.secondFactors = data.authentication.secondFactors;
  }
}

// API call API

class ClientToServerApi {
  constructor({ baseUrl, xOrigin = null }) {
    this._baseUrl = reduceSlashes(baseUrl);
    this.xOrigin = xOrigin;
  }

  get baseUrl() {
    return this._baseUrl;
  }

  set baseUrl(newUrl) {
    this._baseUrl = reduceSlashes(newUrl);
  }

  async call(path, options) {
    try {
      const res = await fetch(`${this._baseUrl}${path}`, options);
      if (res.body) {
        res.data = await res.body.json();
      }
      return res;
    } catch (error) {
      throwFormattedError(error);
    }
  }

  async get(path, options) {
    let headers = options.headers || {}
    if (this.xOrigin) {
      headers = {
        ...(options.headers || {}),
        "x-origin": this.xOrigin
      }
    }
    
    return this.call(path, { ...options, headers, method: "GET" });
  }

  async post(path, payload, options) {
    let headers = options.headers || {}
    if (this.xOrigin) {
      headers = {
        ...(options.headers || {}),
        "x-origin": this.xOrigin
      }
    }
    return this.call(path, { ...options, headers, body: payload, method: "POST" });
  }

  async put(path, payload, options) {
    let headers = options.headers || {}
    if (this.xOrigin) {
      headers = {
        ...(options.headers || {}),
        "x-origin": this.xOrigin
      }
    }
    return this.call(path, { ...options, headers, body: payload, method: "PUT" });
  }

  async redirectTo(url) {
    try {
      if (typeof window !== "undefined" && window.location) {
        window.location.assign(url);
      }
    } catch (error) {
      throwFormattedError(error);
    }
  }
}

// Replace multiple slashes // with single slash / (except in the protocol)
function reduceSlashes(str) {
  return str.replace(/([^:]\/)\/+/g, "$1");
}


// Userfront Core instance

class UserfrontCore {
  constructor({
    tenantId,
    xOrigin = null,
    baseUrl,
    tokenStore
  }) {
    this.tenantId = tenantId;
    this.xOrigin = xOrigin;
    this.user = {};
    this.mode = "live";
    this.baseUrl = baseUrl || apiUrl;
    if (!this.baseUrl.endsWith("/")) {
      this.baseUrl = `${this.baseUrl}/`;
    }
    this.api = new ClientToServerApi({
      baseUrl: this.baseUrl,
      xOrigin
    })

  }
}


class Tenant {
  constructor(tenantId, api) {
    this.tenantId = tenantId;
    this.api = api;
    this.auth = new AuthService();
    this._mode = { value: "test", reason: "" }

  }

  get accessToken() {
    return this.auth.accessToken;
  }

  get idToken() {
    return this.auth.idToken;
  }

  get refreshToken() {
    return this.auth.refreshToken;
  }

  get tokens() {

  }

  addInitCallback(callback) {

  }

  logout() {

  }

  get mode() {
    return this._mode.value;
  }

  refresh() {

  }

  login() {

  }

  sendResetLink() {

  }

  sendVerificationCode() {

  }

  signup() {

  }

  getSession() {

  }

  redirectIfLoggedIn() {

  }

  redirectIfLoggedOut() {

  }

  get user() {

  }

  async signupWithPassword({
    username,
    name,
    email,
    password,
    userData,
    ...config
  }) {
    const { data } = await this.api.post(
      "/auth/create",
      {
        tenantId: this.tenantId,
        username,
        name,
        email,
        password,
        data: userData
      },
      {
        headers: this.auth.getMfaHeaders(),
        params: this.auth.getPkceRequestQueryParams()
      }
    )

    return this.auth.handleLoginResponse({ data, ...config });
  }

  async loginWithPassword({
    email,
    username,
    emailOrUsername,
    password,
    options = {},
    ...config
  }) {
    const body = {
      tenantId: this.tenantId,
      emailOrUsername: email || username || emailOrUsername,
      password
    };
    if (options.noResetEmail) {
      body.options = {
        noResetEmail: true
      }
    }
    const { data } = await this.api.post(
      "/auth/basic",
      body,
      {
        headers: this.auth.getMfaHeaders(),
        params: this.auth.getPkceRequestQueryParams()
      }
    );
    return this.auth.handleLoginResponse({ data, ...config });
  }

  async sendResetLink(email) {
    return await this.api.post(
      "/auth/reset/link",
      {
        email,
        tenantId: this.tenantId
      }
    ).data;
  }

  async resetPassword(...args) { return this.updatePassword(...args) }
  async updatePassword({
    method,
    password,
    existingPassword,
    uuid,
    token,
    ...config
  }) {
    switch (method) {
      // Allow for explicit setting of method
      case "link":
        return this.updatePasswordWithLink({
          uuid,
          token,
          password,
          ...config
        });
      case "jwt":
        return this.updatePasswordWithJwt({ password, existingPassword });
      default:
        // Default (no method provided) is to look for link credentials first, then JWT access token
        token = token || getQueryAttr("token");
        uuid = uuid || getQueryAttr("uuid");
        if (uuid && token) {
          return this.updatePasswordWithLink({
            uuid,
            token,
            password,
            ...config
          });
        } else if (this.accessToken) {
          return this.updatePasswordWithJwt({ password, existingPassword });
        } else {
          throw new Error(
            "updatePassword() was called without link credentials (token & uuid) or a JWT access token."
          );
        }
    }
  }

  async updatePasswordWithLink({
    uuid,
    token,
    password,
    ...config
  }) {
    token = token || getQueryAttr("token");
    uuid = uuid || getQueryAttr("uuid");
    if (!token || !uuid) {
      throw new Error("Missing token or uuid")
    }
    const { data } = await this.api.put(
      "/auth/reset",
      {
        tenantId: this.tenantId,
        uuid,
        token,
        password
      }
    );
    return this.auth.handleLoginResponse({ data, ...config });
  }

  async updatePasswordWithJwt({
    password,
    existingPassword
  }) {
    if (!this.accessToken) {
      throw new Error(
        "updatePassword({ method 'jwt' }) was called without a JWT access token."
      );
    }

    return await this.api.put(
      "/auth/reset",
      {
        tenantId: this.tenantId,
        password,
        existingPassword
      },
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      }
    ).data;
  }

  async loginWithLink({
    token,
    uuid,
    ...rest
  }) {
    token = token || getQueryAttr("token");
    uuid = uuid || getQueryAttr("uuid");
    if (!token || !uuid) {
      return;
    }
    const { data } = await this.api.put(
      "/auth/link",
      {
        tenantId: this.tenantId,
        headers: this.auth.getMfaHeaders(),
        params: this.auth.getPkceRequestQueryParams()
      }
    );

    return this.auth.handleLoginResponse({ data, ...rest });
  }

  async sendLoginLink(email) {
    return await this.api.post(
      "/auth/link",
      {
        tenantId: this.tenantId,
        email
      }
    ).data;
  }

  async sendPasswordlessLink({
    email,
    name,
    username,
    userData,
    options
  }) {
    return await this.api.post(
      "/auth/link",
      {
        tenantId: this.tenantId,
        email,
        name,
        username,
        data: userData,
        options
      }
    ).data;
  }

  async logout({ method, redirect } = {}) {
    if (method === "saml") {
      return this.completeSamlLogout();
    }
    
    try {
      if (this.accessToken) {
        const { data } = await this.api.get(
          "/auth/logout",
          {
            headers: {
              Authorization: `Bearer ${this.accessToken}`
            }
          }
        );
        this.auth.handleRedirect(redirect, data);
      }
    } finally {
      this.auth.removeAllTokens();
    }
  }

  async completeSamlLogout() {
    if (!this.accessToken) {
      throw new Error("Please log in to authorize your logout request.");
    }

    const { data } = await this.api.get(
      "/auth/saml/idp/token",
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      }
    );
    return this.api.redirectTo(`${this.api.baseUrl}auth/saml/idp/logout?tenant_id=${this.tenantId}&token=${data.token}&uuid=${this.user.userUuid}`);
  }

  async setMode() {
    try {
      const { data } = await this.api.get(`/tenants/${this.tenantId}/mode`);
      this._mode.value = data.mode || test;
      this._mode.reason = getReason(mode.value);
      this.auth.setFirstFactors(data.authentication);
      return data;
    } catch (error) {
      this._mode.value = "test";
    }
  }

  setModeSync() {
    const modeValue = isTestHostname() || !isHttps() ? "test" : "live";
    this._mode.value = modeValue;
    this._mode.reason = getReason(modeValue);
  }

  async loginWithPasswordMigrate({
    email,
    username,
    emailOrUsername,
    password,
    options,
    ...rest
  }) {
    const body = {
      tenantId: this.tenantId,
      emailOrUsername: email || username || emailOrUsername,
      password,
    };
    if (options && options.noResetEmail) {
      body.options = {
        noResetEmail: true,
      };
    }
    const { data } = await this.api.post(
      "/auth/password/migrate",
      body,
      {
        headers: this.auth.getMfaHeaders(),
        params: this.auth.getPkceRequestQueryParams()
      }
    );
    return this.auth.handleLoginResponse({
      data,
      ...rest
    })
  }

  async refresh() {
    try {
      const { data, status } = await this.api.get(
        "/auth/refresh",
        {
          headers: {
            Authorization: `Bearer ${this.refreshToken}`
          }
        }
      );
      if (status !== 200) {
        console.warn(`Refresh failed: ${data.message || "Problem with request"}`);
      }
      if (data.tokens) {
        this.auth.setTokens(data.tokens);
        return data;
      }
      console.warn(`Refresh failed: Problem setting cookies`);
    } catch (error) {
      console.warn(`Refresh failed: ${formatError(error).message}`);
    }
  }

  async exchange({ sessionId, nonce }) { return; }

  async completeSamlLogin() {
    if (!this.accessToken) {
      console.warn("Cannot complete SAML login without access token")
      return;
    }
    const { data } = await this.api.get(
      "/auth/saml/idp/token",
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      }
    )
    this.api.redirectTo(`${this.api.baseUrl}auth/saml/idp/login?tenant_id=${this.tenantId}&token=${data.token}&uuid=${this.user.userUuid}`)
  }

  async getIsLoggedIn() {
    try {
      if (this.auth.isAccessTokenLocallyValid()) {
        return true;
      }
      if (!this.auth.isRefreshTokenLocallyValid()) {
        return false;
      }

      await this.refresh();

      return this.auth.isAccessTokenLocallyValid();
    } catch (error) {
      return false;
    }
  }

  async getSession() {
    const isLoggedIn = await this.getIsLoggedIn();
    return {
      isLoggedIn,
      needsSecondFactor: this.auth.isFirstFactorTokenPresent(),
      firstFactors: this.auth.firstFactors,
      secondFactors: this.auth.secondFactors,
      resetMfaState: this.auth.clearMfa
    }
  }
}